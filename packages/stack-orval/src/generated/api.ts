/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * MyApp API
 * „É¶„Éº„Ç∂„ÉºÁÆ°ÁêÜAPI
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateComment,
  CreatePost,
  CreateTag,
  CreateUser,
  ErrorResponse,
  GetCommentsApi200,
  GetCommentsApiParams,
  GetCommentsByIdApi200,
  GetPostsApi200,
  GetPostsApiParams,
  GetPostsByIdApi200,
  GetTagsApi200,
  GetTagsByIdApi200,
  GetUsersApi200,
  GetUsersByIdApi200,
  PostCommentsApi201,
  PostPostsApi201,
  PostTagsApi201,
  PostUsersApi201,
  PutCommentsByIdApi200,
  PutPostsByIdApi200,
  UpdateComment,
  UpdatePost
} from './model';





/**
 * „Ç∑„Çπ„ÉÜ„É†„Å´ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åô„Åπ„Å¶„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó„Åó„Åæ„Åô
 * @summary ÂÖ®„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó
 */
export type getUsersApiResponse200 = {
  data: GetUsersApi200
  status: 200
}

export type getUsersApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type getUsersApiResponseComposite = getUsersApiResponse200 | getUsersApiResponse400;
    
export type getUsersApiResponse = getUsersApiResponseComposite & {
  headers: Headers;
}

export const getGetUsersApiUrl = () => {


  

  return `http://localhost:4010/api/users`
}

export const getUsersApi = async ( options?: RequestInit): Promise<getUsersApiResponse> => {
  
  const res = await fetch(getGetUsersApiUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getUsersApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getUsersApiResponse
}



export const getGetUsersApiQueryKey = () => {
    return [`http://localhost:4010/api/users`] as const;
    }

    
export const getGetUsersApiQueryOptions = <TData = Awaited<ReturnType<typeof getUsersApi>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApi>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersApiQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersApi>>> = ({ signal }) => getUsersApi({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersApiQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersApi>>>
export type GetUsersApiQueryError = ErrorResponse


export function useGetUsersApi<TData = Awaited<ReturnType<typeof getUsersApi>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersApi>>,
          TError,
          Awaited<ReturnType<typeof getUsersApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersApi<TData = Awaited<ReturnType<typeof getUsersApi>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersApi>>,
          TError,
          Awaited<ReturnType<typeof getUsersApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersApi<TData = Awaited<ReturnType<typeof getUsersApi>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÂÖ®„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó
 */

export function useGetUsersApi<TData = Awaited<ReturnType<typeof getUsersApi>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersApiQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Êñ∞„Åó„ÅÑ„É¶„Éº„Ç∂„Éº„Çí„Ç∑„Çπ„ÉÜ„É†„Å´ÁôªÈå≤„Åó„Åæ„Åô
 * @summary Êñ∞Ë¶è„É¶„Éº„Ç∂„Éº„Çí‰ΩúÊàê
 */
export type postUsersApiResponse201 = {
  data: PostUsersApi201
  status: 201
}

export type postUsersApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type postUsersApiResponseComposite = postUsersApiResponse201 | postUsersApiResponse400;
    
export type postUsersApiResponse = postUsersApiResponseComposite & {
  headers: Headers;
}

export const getPostUsersApiUrl = () => {


  

  return `http://localhost:4010/api/users`
}

export const postUsersApi = async (createUser: CreateUser, options?: RequestInit): Promise<postUsersApiResponse> => {
  
  const res = await fetch(getPostUsersApiUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUser,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postUsersApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postUsersApiResponse
}




export const getPostUsersApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersApi>>, TError,{data: CreateUser}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postUsersApi>>, TError,{data: CreateUser}, TContext> => {

const mutationKey = ['postUsersApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersApi>>, {data: CreateUser}> = (props) => {
          const {data} = props ?? {};

          return  postUsersApi(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsersApiMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersApi>>>
    export type PostUsersApiMutationBody = CreateUser
    export type PostUsersApiMutationError = ErrorResponse

    /**
 * @summary Êñ∞Ë¶è„É¶„Éº„Ç∂„Éº„Çí‰ΩúÊàê
 */
export const usePostUsersApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersApi>>, TError,{data: CreateUser}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postUsersApi>>,
        TError,
        {data: CreateUser},
        TContext
      > => {

      const mutationOptions = getPostUsersApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆ„É¶„Éº„Ç∂„ÉºÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Åæ„Åô
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó
 */
export type getUsersByIdApiResponse200 = {
  data: GetUsersByIdApi200
  status: 200
}

export type getUsersByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type getUsersByIdApiResponseComposite = getUsersByIdApiResponse200 | getUsersByIdApiResponse400;
    
export type getUsersByIdApiResponse = getUsersByIdApiResponseComposite & {
  headers: Headers;
}

export const getGetUsersByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/users/${id}`
}

export const getUsersByIdApi = async (id: string, options?: RequestInit): Promise<getUsersByIdApiResponse> => {
  
  const res = await fetch(getGetUsersByIdApiUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getUsersByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getUsersByIdApiResponse
}



export const getGetUsersByIdApiQueryKey = (id: string,) => {
    return [`http://localhost:4010/api/users/${id}`] as const;
    }

    
export const getGetUsersByIdApiQueryOptions = <TData = Awaited<ReturnType<typeof getUsersByIdApi>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByIdApi>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByIdApiQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByIdApi>>> = ({ signal }) => getUsersByIdApi(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersByIdApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersByIdApiQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByIdApi>>>
export type GetUsersByIdApiQueryError = ErrorResponse


export function useGetUsersByIdApi<TData = Awaited<ReturnType<typeof getUsersByIdApi>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByIdApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByIdApi>>,
          TError,
          Awaited<ReturnType<typeof getUsersByIdApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersByIdApi<TData = Awaited<ReturnType<typeof getUsersByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByIdApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByIdApi>>,
          TError,
          Awaited<ReturnType<typeof getUsersByIdApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersByIdApi<TData = Awaited<ReturnType<typeof getUsersByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByIdApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó
 */

export function useGetUsersByIdApi<TData = Awaited<ReturnType<typeof getUsersByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByIdApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersByIdApiQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åó„Åæ„Åô
 * @summary „É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§
 */
export type deleteUsersByIdApiResponse204 = {
  data: void
  status: 204
}

export type deleteUsersByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type deleteUsersByIdApiResponseComposite = deleteUsersByIdApiResponse204 | deleteUsersByIdApiResponse400;
    
export type deleteUsersByIdApiResponse = deleteUsersByIdApiResponseComposite & {
  headers: Headers;
}

export const getDeleteUsersByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/users/${id}`
}

export const deleteUsersByIdApi = async (id: string, options?: RequestInit): Promise<deleteUsersByIdApiResponse> => {
  
  const res = await fetch(getDeleteUsersByIdApiUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteUsersByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteUsersByIdApiResponse
}




export const getDeleteUsersByIdApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersByIdApi>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsersByIdApi>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteUsersByIdApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsersByIdApi>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUsersByIdApi(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUsersByIdApiMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsersByIdApi>>>
    
    export type DeleteUsersByIdApiMutationError = ErrorResponse

    /**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§
 */
export const useDeleteUsersByIdApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersByIdApi>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUsersByIdApi>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteUsersByIdApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * „Ç∑„Çπ„ÉÜ„É†„Å´ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åô„Åπ„Å¶„ÅÆÊäïÁ®ø„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇÂÖ¨ÈñãÁä∂ÊÖã„Åß„Éï„Ç£„É´„ÇøÂèØËÉΩ
 * @summary ÂÖ®ÊäïÁ®ø„ÇíÂèñÂæó
 */
export type getPostsApiResponse200 = {
  data: GetPostsApi200
  status: 200
}

export type getPostsApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type getPostsApiResponseComposite = getPostsApiResponse200 | getPostsApiResponse400;
    
export type getPostsApiResponse = getPostsApiResponseComposite & {
  headers: Headers;
}

export const getGetPostsApiUrl = (params?: GetPostsApiParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:4010/api/posts?${stringifiedParams}` : `http://localhost:4010/api/posts`
}

export const getPostsApi = async (params?: GetPostsApiParams, options?: RequestInit): Promise<getPostsApiResponse> => {
  
  const res = await fetch(getGetPostsApiUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPostsApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPostsApiResponse
}



export const getGetPostsApiQueryKey = (params?: GetPostsApiParams,) => {
    return [`http://localhost:4010/api/posts`, ...(params ? [params]: [])] as const;
    }

    
export const getGetPostsApiQueryOptions = <TData = Awaited<ReturnType<typeof getPostsApi>>, TError = ErrorResponse>(params?: GetPostsApiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsApi>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPostsApiQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostsApi>>> = ({ signal }) => getPostsApi(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPostsApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPostsApiQueryResult = NonNullable<Awaited<ReturnType<typeof getPostsApi>>>
export type GetPostsApiQueryError = ErrorResponse


export function useGetPostsApi<TData = Awaited<ReturnType<typeof getPostsApi>>, TError = ErrorResponse>(
 params: undefined |  GetPostsApiParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsApi>>,
          TError,
          Awaited<ReturnType<typeof getPostsApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostsApi<TData = Awaited<ReturnType<typeof getPostsApi>>, TError = ErrorResponse>(
 params?: GetPostsApiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsApi>>,
          TError,
          Awaited<ReturnType<typeof getPostsApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostsApi<TData = Awaited<ReturnType<typeof getPostsApi>>, TError = ErrorResponse>(
 params?: GetPostsApiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÂÖ®ÊäïÁ®ø„ÇíÂèñÂæó
 */

export function useGetPostsApi<TData = Awaited<ReturnType<typeof getPostsApi>>, TError = ErrorResponse>(
 params?: GetPostsApiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPostsApiQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Êñ∞„Åó„ÅÑÊäïÁ®ø„Çí„Ç∑„Çπ„ÉÜ„É†„Å´ÁôªÈå≤„Åó„Åæ„Åô
 * @summary Êñ∞Ë¶èÊäïÁ®ø„Çí‰ΩúÊàê
 */
export type postPostsApiResponse201 = {
  data: PostPostsApi201
  status: 201
}

export type postPostsApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type postPostsApiResponseComposite = postPostsApiResponse201 | postPostsApiResponse400;
    
export type postPostsApiResponse = postPostsApiResponseComposite & {
  headers: Headers;
}

export const getPostPostsApiUrl = () => {


  

  return `http://localhost:4010/api/posts`
}

export const postPostsApi = async (createPost: CreatePost, options?: RequestInit): Promise<postPostsApiResponse> => {
  
  const res = await fetch(getPostPostsApiUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPost,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postPostsApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postPostsApiResponse
}




export const getPostPostsApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPostsApi>>, TError,{data: CreatePost}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postPostsApi>>, TError,{data: CreatePost}, TContext> => {

const mutationKey = ['postPostsApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPostsApi>>, {data: CreatePost}> = (props) => {
          const {data} = props ?? {};

          return  postPostsApi(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostPostsApiMutationResult = NonNullable<Awaited<ReturnType<typeof postPostsApi>>>
    export type PostPostsApiMutationBody = CreatePost
    export type PostPostsApiMutationError = ErrorResponse

    /**
 * @summary Êñ∞Ë¶èÊäïÁ®ø„Çí‰ΩúÊàê
 */
export const usePostPostsApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPostsApi>>, TError,{data: CreatePost}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPostsApi>>,
        TError,
        {data: CreatePost},
        TContext
      > => {

      const mutationOptions = getPostPostsApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆÊäïÁ®øÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Åæ„Åô
 * @summary ÁâπÂÆö„ÅÆÊäïÁ®ø„ÇíÂèñÂæó
 */
export type getPostsByIdApiResponse200 = {
  data: GetPostsByIdApi200
  status: 200
}

export type getPostsByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type getPostsByIdApiResponseComposite = getPostsByIdApiResponse200 | getPostsByIdApiResponse400;
    
export type getPostsByIdApiResponse = getPostsByIdApiResponseComposite & {
  headers: Headers;
}

export const getGetPostsByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/posts/${id}`
}

export const getPostsByIdApi = async (id: string, options?: RequestInit): Promise<getPostsByIdApiResponse> => {
  
  const res = await fetch(getGetPostsByIdApiUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPostsByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPostsByIdApiResponse
}



export const getGetPostsByIdApiQueryKey = (id: string,) => {
    return [`http://localhost:4010/api/posts/${id}`] as const;
    }

    
export const getGetPostsByIdApiQueryOptions = <TData = Awaited<ReturnType<typeof getPostsByIdApi>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByIdApi>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPostsByIdApiQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostsByIdApi>>> = ({ signal }) => getPostsByIdApi(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPostsByIdApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPostsByIdApiQueryResult = NonNullable<Awaited<ReturnType<typeof getPostsByIdApi>>>
export type GetPostsByIdApiQueryError = ErrorResponse


export function useGetPostsByIdApi<TData = Awaited<ReturnType<typeof getPostsByIdApi>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByIdApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsByIdApi>>,
          TError,
          Awaited<ReturnType<typeof getPostsByIdApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostsByIdApi<TData = Awaited<ReturnType<typeof getPostsByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByIdApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsByIdApi>>,
          TError,
          Awaited<ReturnType<typeof getPostsByIdApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostsByIdApi<TData = Awaited<ReturnType<typeof getPostsByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByIdApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÁâπÂÆö„ÅÆÊäïÁ®ø„ÇíÂèñÂæó
 */

export function useGetPostsByIdApi<TData = Awaited<ReturnType<typeof getPostsByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsByIdApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPostsByIdApiQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆÊäïÁ®ø„ÇíÊõ¥Êñ∞„Åó„Åæ„Åô
 * @summary ÊäïÁ®ø„ÇíÊõ¥Êñ∞
 */
export type putPostsByIdApiResponse200 = {
  data: PutPostsByIdApi200
  status: 200
}

export type putPostsByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type putPostsByIdApiResponseComposite = putPostsByIdApiResponse200 | putPostsByIdApiResponse400;
    
export type putPostsByIdApiResponse = putPostsByIdApiResponseComposite & {
  headers: Headers;
}

export const getPutPostsByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/posts/${id}`
}

export const putPostsByIdApi = async (id: string,
    updatePost: UpdatePost, options?: RequestInit): Promise<putPostsByIdApiResponse> => {
  
  const res = await fetch(getPutPostsByIdApiUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePost,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: putPostsByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as putPostsByIdApiResponse
}




export const getPutPostsByIdApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPostsByIdApi>>, TError,{id: string;data: UpdatePost}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putPostsByIdApi>>, TError,{id: string;data: UpdatePost}, TContext> => {

const mutationKey = ['putPostsByIdApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putPostsByIdApi>>, {id: string;data: UpdatePost}> = (props) => {
          const {id,data} = props ?? {};

          return  putPostsByIdApi(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutPostsByIdApiMutationResult = NonNullable<Awaited<ReturnType<typeof putPostsByIdApi>>>
    export type PutPostsByIdApiMutationBody = UpdatePost
    export type PutPostsByIdApiMutationError = ErrorResponse

    /**
 * @summary ÊäïÁ®ø„ÇíÊõ¥Êñ∞
 */
export const usePutPostsByIdApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putPostsByIdApi>>, TError,{id: string;data: UpdatePost}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putPostsByIdApi>>,
        TError,
        {id: string;data: UpdatePost},
        TContext
      > => {

      const mutationOptions = getPutPostsByIdApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆÊäïÁ®ø„ÇíÂâäÈô§„Åó„Åæ„Åô
 * @summary ÊäïÁ®ø„ÇíÂâäÈô§
 */
export type deletePostsByIdApiResponse204 = {
  data: void
  status: 204
}

export type deletePostsByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type deletePostsByIdApiResponseComposite = deletePostsByIdApiResponse204 | deletePostsByIdApiResponse400;
    
export type deletePostsByIdApiResponse = deletePostsByIdApiResponseComposite & {
  headers: Headers;
}

export const getDeletePostsByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/posts/${id}`
}

export const deletePostsByIdApi = async (id: string, options?: RequestInit): Promise<deletePostsByIdApiResponse> => {
  
  const res = await fetch(getDeletePostsByIdApiUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deletePostsByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deletePostsByIdApiResponse
}




export const getDeletePostsByIdApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePostsByIdApi>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deletePostsByIdApi>>, TError,{id: string}, TContext> => {

const mutationKey = ['deletePostsByIdApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePostsByIdApi>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deletePostsByIdApi(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePostsByIdApiMutationResult = NonNullable<Awaited<ReturnType<typeof deletePostsByIdApi>>>
    
    export type DeletePostsByIdApiMutationError = ErrorResponse

    /**
 * @summary ÊäïÁ®ø„ÇíÂâäÈô§
 */
export const useDeletePostsByIdApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePostsByIdApi>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePostsByIdApi>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeletePostsByIdApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * „Ç∑„Çπ„ÉÜ„É†„Å´ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åô„Åπ„Å¶„ÅÆ„Çø„Ç∞„ÇíÂèñÂæó„Åó„Åæ„Åô
 * @summary ÂÖ®„Çø„Ç∞„ÇíÂèñÂæó
 */
export type getTagsApiResponse200 = {
  data: GetTagsApi200
  status: 200
}

export type getTagsApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type getTagsApiResponseComposite = getTagsApiResponse200 | getTagsApiResponse400;
    
export type getTagsApiResponse = getTagsApiResponseComposite & {
  headers: Headers;
}

export const getGetTagsApiUrl = () => {


  

  return `http://localhost:4010/api/tags`
}

export const getTagsApi = async ( options?: RequestInit): Promise<getTagsApiResponse> => {
  
  const res = await fetch(getGetTagsApiUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTagsApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getTagsApiResponse
}



export const getGetTagsApiQueryKey = () => {
    return [`http://localhost:4010/api/tags`] as const;
    }

    
export const getGetTagsApiQueryOptions = <TData = Awaited<ReturnType<typeof getTagsApi>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsApi>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTagsApiQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTagsApi>>> = ({ signal }) => getTagsApi({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTagsApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTagsApiQueryResult = NonNullable<Awaited<ReturnType<typeof getTagsApi>>>
export type GetTagsApiQueryError = ErrorResponse


export function useGetTagsApi<TData = Awaited<ReturnType<typeof getTagsApi>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTagsApi>>,
          TError,
          Awaited<ReturnType<typeof getTagsApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTagsApi<TData = Awaited<ReturnType<typeof getTagsApi>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTagsApi>>,
          TError,
          Awaited<ReturnType<typeof getTagsApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTagsApi<TData = Awaited<ReturnType<typeof getTagsApi>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÂÖ®„Çø„Ç∞„ÇíÂèñÂæó
 */

export function useGetTagsApi<TData = Awaited<ReturnType<typeof getTagsApi>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTagsApiQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Êñ∞„Åó„ÅÑ„Çø„Ç∞„Çí„Ç∑„Çπ„ÉÜ„É†„Å´ÁôªÈå≤„Åó„Åæ„Åô
 * @summary Êñ∞Ë¶è„Çø„Ç∞„Çí‰ΩúÊàê
 */
export type postTagsApiResponse201 = {
  data: PostTagsApi201
  status: 201
}

export type postTagsApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type postTagsApiResponseComposite = postTagsApiResponse201 | postTagsApiResponse400;
    
export type postTagsApiResponse = postTagsApiResponseComposite & {
  headers: Headers;
}

export const getPostTagsApiUrl = () => {


  

  return `http://localhost:4010/api/tags`
}

export const postTagsApi = async (createTag: CreateTag, options?: RequestInit): Promise<postTagsApiResponse> => {
  
  const res = await fetch(getPostTagsApiUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTag,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postTagsApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postTagsApiResponse
}




export const getPostTagsApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTagsApi>>, TError,{data: CreateTag}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postTagsApi>>, TError,{data: CreateTag}, TContext> => {

const mutationKey = ['postTagsApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTagsApi>>, {data: CreateTag}> = (props) => {
          const {data} = props ?? {};

          return  postTagsApi(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostTagsApiMutationResult = NonNullable<Awaited<ReturnType<typeof postTagsApi>>>
    export type PostTagsApiMutationBody = CreateTag
    export type PostTagsApiMutationError = ErrorResponse

    /**
 * @summary Êñ∞Ë¶è„Çø„Ç∞„Çí‰ΩúÊàê
 */
export const usePostTagsApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTagsApi>>, TError,{data: CreateTag}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTagsApi>>,
        TError,
        {data: CreateTag},
        TContext
      > => {

      const mutationOptions = getPostTagsApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆ„Çø„Ç∞ÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Åæ„Åô
 * @summary ÁâπÂÆö„ÅÆ„Çø„Ç∞„ÇíÂèñÂæó
 */
export type getTagsByIdApiResponse200 = {
  data: GetTagsByIdApi200
  status: 200
}

export type getTagsByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type getTagsByIdApiResponseComposite = getTagsByIdApiResponse200 | getTagsByIdApiResponse400;
    
export type getTagsByIdApiResponse = getTagsByIdApiResponseComposite & {
  headers: Headers;
}

export const getGetTagsByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/tags/${id}`
}

export const getTagsByIdApi = async (id: string, options?: RequestInit): Promise<getTagsByIdApiResponse> => {
  
  const res = await fetch(getGetTagsByIdApiUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTagsByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getTagsByIdApiResponse
}



export const getGetTagsByIdApiQueryKey = (id: string,) => {
    return [`http://localhost:4010/api/tags/${id}`] as const;
    }

    
export const getGetTagsByIdApiQueryOptions = <TData = Awaited<ReturnType<typeof getTagsByIdApi>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsByIdApi>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTagsByIdApiQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTagsByIdApi>>> = ({ signal }) => getTagsByIdApi(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTagsByIdApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTagsByIdApiQueryResult = NonNullable<Awaited<ReturnType<typeof getTagsByIdApi>>>
export type GetTagsByIdApiQueryError = ErrorResponse


export function useGetTagsByIdApi<TData = Awaited<ReturnType<typeof getTagsByIdApi>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsByIdApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTagsByIdApi>>,
          TError,
          Awaited<ReturnType<typeof getTagsByIdApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTagsByIdApi<TData = Awaited<ReturnType<typeof getTagsByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsByIdApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTagsByIdApi>>,
          TError,
          Awaited<ReturnType<typeof getTagsByIdApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTagsByIdApi<TData = Awaited<ReturnType<typeof getTagsByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsByIdApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÁâπÂÆö„ÅÆ„Çø„Ç∞„ÇíÂèñÂæó
 */

export function useGetTagsByIdApi<TData = Awaited<ReturnType<typeof getTagsByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsByIdApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTagsByIdApiQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆ„Çø„Ç∞„ÇíÂâäÈô§„Åó„Åæ„Åô
 * @summary „Çø„Ç∞„ÇíÂâäÈô§
 */
export type deleteTagsByIdApiResponse204 = {
  data: void
  status: 204
}

export type deleteTagsByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type deleteTagsByIdApiResponseComposite = deleteTagsByIdApiResponse204 | deleteTagsByIdApiResponse400;
    
export type deleteTagsByIdApiResponse = deleteTagsByIdApiResponseComposite & {
  headers: Headers;
}

export const getDeleteTagsByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/tags/${id}`
}

export const deleteTagsByIdApi = async (id: string, options?: RequestInit): Promise<deleteTagsByIdApiResponse> => {
  
  const res = await fetch(getDeleteTagsByIdApiUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteTagsByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteTagsByIdApiResponse
}




export const getDeleteTagsByIdApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTagsByIdApi>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTagsByIdApi>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteTagsByIdApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTagsByIdApi>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteTagsByIdApi(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTagsByIdApiMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTagsByIdApi>>>
    
    export type DeleteTagsByIdApiMutationError = ErrorResponse

    /**
 * @summary „Çø„Ç∞„ÇíÂâäÈô§
 */
export const useDeleteTagsByIdApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTagsByIdApi>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTagsByIdApi>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteTagsByIdApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüÊäïÁ®øID„Å´Èñ¢ÈÄ£„Åô„Çã„Åô„Åπ„Å¶„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÂèñÂæó„Åó„Åæ„Åô
 * @summary ÁâπÂÆö„ÅÆÊäïÁ®ø„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÂèñÂæó
 */
export type getCommentsApiResponse200 = {
  data: GetCommentsApi200
  status: 200
}

export type getCommentsApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type getCommentsApiResponseComposite = getCommentsApiResponse200 | getCommentsApiResponse400;
    
export type getCommentsApiResponse = getCommentsApiResponseComposite & {
  headers: Headers;
}

export const getGetCommentsApiUrl = (params: GetCommentsApiParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://localhost:4010/api/comments?${stringifiedParams}` : `http://localhost:4010/api/comments`
}

export const getCommentsApi = async (params: GetCommentsApiParams, options?: RequestInit): Promise<getCommentsApiResponse> => {
  
  const res = await fetch(getGetCommentsApiUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getCommentsApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getCommentsApiResponse
}



export const getGetCommentsApiQueryKey = (params: GetCommentsApiParams,) => {
    return [`http://localhost:4010/api/comments`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCommentsApiQueryOptions = <TData = Awaited<ReturnType<typeof getCommentsApi>>, TError = ErrorResponse>(params: GetCommentsApiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsApi>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCommentsApiQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCommentsApi>>> = ({ signal }) => getCommentsApi(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCommentsApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCommentsApiQueryResult = NonNullable<Awaited<ReturnType<typeof getCommentsApi>>>
export type GetCommentsApiQueryError = ErrorResponse


export function useGetCommentsApi<TData = Awaited<ReturnType<typeof getCommentsApi>>, TError = ErrorResponse>(
 params: GetCommentsApiParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCommentsApi>>,
          TError,
          Awaited<ReturnType<typeof getCommentsApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCommentsApi<TData = Awaited<ReturnType<typeof getCommentsApi>>, TError = ErrorResponse>(
 params: GetCommentsApiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCommentsApi>>,
          TError,
          Awaited<ReturnType<typeof getCommentsApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCommentsApi<TData = Awaited<ReturnType<typeof getCommentsApi>>, TError = ErrorResponse>(
 params: GetCommentsApiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÁâπÂÆö„ÅÆÊäïÁ®ø„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÂèñÂæó
 */

export function useGetCommentsApi<TData = Awaited<ReturnType<typeof getCommentsApi>>, TError = ErrorResponse>(
 params: GetCommentsApiParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCommentsApiQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Êñ∞„Åó„ÅÑ„Ç≥„É°„É≥„Éà„Çí„Ç∑„Çπ„ÉÜ„É†„Å´ÁôªÈå≤„Åó„Åæ„Åô
 * @summary Êñ∞Ë¶è„Ç≥„É°„É≥„Éà„Çí‰ΩúÊàê
 */
export type postCommentsApiResponse201 = {
  data: PostCommentsApi201
  status: 201
}

export type postCommentsApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type postCommentsApiResponseComposite = postCommentsApiResponse201 | postCommentsApiResponse400;
    
export type postCommentsApiResponse = postCommentsApiResponseComposite & {
  headers: Headers;
}

export const getPostCommentsApiUrl = () => {


  

  return `http://localhost:4010/api/comments`
}

export const postCommentsApi = async (createComment: CreateComment, options?: RequestInit): Promise<postCommentsApiResponse> => {
  
  const res = await fetch(getPostCommentsApiUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createComment,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postCommentsApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postCommentsApiResponse
}




export const getPostCommentsApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCommentsApi>>, TError,{data: CreateComment}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postCommentsApi>>, TError,{data: CreateComment}, TContext> => {

const mutationKey = ['postCommentsApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCommentsApi>>, {data: CreateComment}> = (props) => {
          const {data} = props ?? {};

          return  postCommentsApi(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostCommentsApiMutationResult = NonNullable<Awaited<ReturnType<typeof postCommentsApi>>>
    export type PostCommentsApiMutationBody = CreateComment
    export type PostCommentsApiMutationError = ErrorResponse

    /**
 * @summary Êñ∞Ë¶è„Ç≥„É°„É≥„Éà„Çí‰ΩúÊàê
 */
export const usePostCommentsApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCommentsApi>>, TError,{data: CreateComment}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postCommentsApi>>,
        TError,
        {data: CreateComment},
        TContext
      > => {

      const mutationOptions = getPostCommentsApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆ„Ç≥„É°„É≥„ÉàÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Åæ„Åô
 * @summary ÁâπÂÆö„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÂèñÂæó
 */
export type getCommentsByIdApiResponse200 = {
  data: GetCommentsByIdApi200
  status: 200
}

export type getCommentsByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type getCommentsByIdApiResponseComposite = getCommentsByIdApiResponse200 | getCommentsByIdApiResponse400;
    
export type getCommentsByIdApiResponse = getCommentsByIdApiResponseComposite & {
  headers: Headers;
}

export const getGetCommentsByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/comments/${id}`
}

export const getCommentsByIdApi = async (id: string, options?: RequestInit): Promise<getCommentsByIdApiResponse> => {
  
  const res = await fetch(getGetCommentsByIdApiUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getCommentsByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getCommentsByIdApiResponse
}



export const getGetCommentsByIdApiQueryKey = (id: string,) => {
    return [`http://localhost:4010/api/comments/${id}`] as const;
    }

    
export const getGetCommentsByIdApiQueryOptions = <TData = Awaited<ReturnType<typeof getCommentsByIdApi>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsByIdApi>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCommentsByIdApiQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCommentsByIdApi>>> = ({ signal }) => getCommentsByIdApi(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCommentsByIdApi>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCommentsByIdApiQueryResult = NonNullable<Awaited<ReturnType<typeof getCommentsByIdApi>>>
export type GetCommentsByIdApiQueryError = ErrorResponse


export function useGetCommentsByIdApi<TData = Awaited<ReturnType<typeof getCommentsByIdApi>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsByIdApi>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCommentsByIdApi>>,
          TError,
          Awaited<ReturnType<typeof getCommentsByIdApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCommentsByIdApi<TData = Awaited<ReturnType<typeof getCommentsByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsByIdApi>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCommentsByIdApi>>,
          TError,
          Awaited<ReturnType<typeof getCommentsByIdApi>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCommentsByIdApi<TData = Awaited<ReturnType<typeof getCommentsByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsByIdApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÁâπÂÆö„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÂèñÂæó
 */

export function useGetCommentsByIdApi<TData = Awaited<ReturnType<typeof getCommentsByIdApi>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCommentsByIdApi>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCommentsByIdApiQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÊõ¥Êñ∞„Åó„Åæ„Åô
 * @summary „Ç≥„É°„É≥„Éà„ÇíÊõ¥Êñ∞
 */
export type putCommentsByIdApiResponse200 = {
  data: PutCommentsByIdApi200
  status: 200
}

export type putCommentsByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type putCommentsByIdApiResponseComposite = putCommentsByIdApiResponse200 | putCommentsByIdApiResponse400;
    
export type putCommentsByIdApiResponse = putCommentsByIdApiResponseComposite & {
  headers: Headers;
}

export const getPutCommentsByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/comments/${id}`
}

export const putCommentsByIdApi = async (id: string,
    updateComment: UpdateComment, options?: RequestInit): Promise<putCommentsByIdApiResponse> => {
  
  const res = await fetch(getPutCommentsByIdApiUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateComment,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: putCommentsByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as putCommentsByIdApiResponse
}




export const getPutCommentsByIdApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putCommentsByIdApi>>, TError,{id: string;data: UpdateComment}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putCommentsByIdApi>>, TError,{id: string;data: UpdateComment}, TContext> => {

const mutationKey = ['putCommentsByIdApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putCommentsByIdApi>>, {id: string;data: UpdateComment}> = (props) => {
          const {id,data} = props ?? {};

          return  putCommentsByIdApi(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutCommentsByIdApiMutationResult = NonNullable<Awaited<ReturnType<typeof putCommentsByIdApi>>>
    export type PutCommentsByIdApiMutationBody = UpdateComment
    export type PutCommentsByIdApiMutationError = ErrorResponse

    /**
 * @summary „Ç≥„É°„É≥„Éà„ÇíÊõ¥Êñ∞
 */
export const usePutCommentsByIdApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putCommentsByIdApi>>, TError,{id: string;data: UpdateComment}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putCommentsByIdApi>>,
        TError,
        {id: string;data: UpdateComment},
        TContext
      > => {

      const mutationOptions = getPutCommentsByIdApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô
 * @summary „Ç≥„É°„É≥„Éà„ÇíÂâäÈô§
 */
export type deleteCommentsByIdApiResponse204 = {
  data: void
  status: 204
}

export type deleteCommentsByIdApiResponse400 = {
  data: ErrorResponse
  status: 400
}
    
export type deleteCommentsByIdApiResponseComposite = deleteCommentsByIdApiResponse204 | deleteCommentsByIdApiResponse400;
    
export type deleteCommentsByIdApiResponse = deleteCommentsByIdApiResponseComposite & {
  headers: Headers;
}

export const getDeleteCommentsByIdApiUrl = (id: string,) => {


  

  return `http://localhost:4010/api/comments/${id}`
}

export const deleteCommentsByIdApi = async (id: string, options?: RequestInit): Promise<deleteCommentsByIdApiResponse> => {
  
  const res = await fetch(getDeleteCommentsByIdApiUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteCommentsByIdApiResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteCommentsByIdApiResponse
}




export const getDeleteCommentsByIdApiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCommentsByIdApi>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCommentsByIdApi>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteCommentsByIdApi'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCommentsByIdApi>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteCommentsByIdApi(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCommentsByIdApiMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCommentsByIdApi>>>
    
    export type DeleteCommentsByIdApiMutationError = ErrorResponse

    /**
 * @summary „Ç≥„É°„É≥„Éà„ÇíÂâäÈô§
 */
export const useDeleteCommentsByIdApi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCommentsByIdApi>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCommentsByIdApi>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteCommentsByIdApiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
